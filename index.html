<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
import { getFirestore, collection, getDocs } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

// Firebase 설정
const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_PROJECT_ID.firebaseapp.com",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_PROJECT_ID.appspot.com",
  messagingSenderId: "YOUR_SENDER_ID",
  appId: "YOUR_APP_ID"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

// Firestore에서 letters 불러오기
async function fetchLetters() {
  const letters = [];
  try {
    const querySnapshot = await getDocs(collection(db, "letters")); // 컬렉션 이름 "letters"
    querySnapshot.forEach((doc) => {
      letters.push(doc.data().text); // 문서 안에 "text" 필드가 있다고 가정
    });
  } catch (error) {
    console.error("Firestore 불러오기 실패:", error);
  }
  return letters;
}

// 기존 typing() 호출 부분 수정
window.onload = async function () {
  time();
  const lettersFromDB = await fetchLetters();
  if (lettersFromDB.length > 0) {
    typing(lettersFromDB); // Firestore 데이터 전달
  } else {
    typing(["데이터 없음"]); // Firestore 데이터 없을 경우 기본값
  }
};

// typing 함수에 letters 파라미터 추가
function typing(letters) {
  const $text = document.querySelector(".typing .text");
  let i = 0;
  const speed = 115;

  const wait = (ms) => new Promise(res => setTimeout(res, ms));

  const typingFunc = async () => {
    if (!typingLoopActive) return;
    $text.innerHTML = "";
    const raw = letters[i];

    // 기존 wordList 및 타이핑 + 브릭 생성 로직 그대로 사용
    const wordList = [
      { words: ["L", "후원", "구독", "감사", "다시", "YOON", "٩", "و"], color: "red" },
      { words: ["0","1","2","3","4","5","6","7","8","9",".","★","ᗜ","*"], color: "#FFC700" },
      { words: ["AGAIN"], color: "#6495ED" },
      { words: ["ㅡ"], color: "transparent" }
    ];

    const typingChars = [];
    const consumed = Array(raw.length).fill(false);

    for (const group of wordList) {
      for (const word of group.words) {
        let startIndex = 0;
        while (startIndex < raw.length) {
          const index = raw.indexOf(word, startIndex);
          if (index === -1) break;
          for (let j = 0; j < word.length; j++) {
            typingChars[index + j] = { char: word[j], color: group.color };
            consumed[index + j] = true;
          }
          startIndex = index + 1;
        }
      }
    }

    for (let j = 0; j < raw.length; j++) {
      if (!consumed[j]) typingChars[j] = { char: raw[j], color: "white" };
    }

    for (const { char, color } of typingChars) {
      if (!typingLoopActive) return;
      await wait(speed);
      const span = document.createElement("span");
      span.textContent = char;
      span.style.color = color;
      if (color === "transparent") span.style.textShadow = "none";
      $text.appendChild(span);

      const rect = span.getBoundingClientRect();
      const x = rect.right + window.scrollX + 15;
      const y = rect.top + rect.height / 2 + window.scrollY + 10;

      const actualColor = (color === "transparent") ? "white" : color;
      createBricksBatch(x, y, actualColor, 10);
    }

    await wait(14000);
    reverseTyping();
  };

  const reverseTyping = async () => {
    const spans = Array.from($text.childNodes).reverse();
    for (let span of spans) {
      if (!typingLoopActive) return;
      await wait(speed);
      const rect = span.getBoundingClientRect();
      const x = rect.left + rect.width / 2 + window.scrollX;
      const y = rect.top + rect.height / 2 + window.scrollY + 10;
      const color = (span.style.color === "transparent") ? "white" : span.style.color;
      createBricksBatch(x, y, color, 10);

      span.remove();
      span.textContent = "";
      span.removeAttribute("style");
      span.removeAttribute("class");
      span = null;
    }
    $text.innerHTML = "";
    i = (i + 1) % letters.length;
    typingFunc();
  };

  setTimeout(typingFunc, 1000);
}
</script>
